get_ipython().run_cell_magic('bash', '', 'sqlplus -s mnist/mnist@dbserver:1521/orcl.cern.ch  <<EOF\n\n-- create the table for test data, where the images of digits are stored as arrays of type utl_nla_array\ncreate table testdata_array as\nselect a.image_id, a.label, \ncast(multiset(select val from testdata where image_id=a.image_id order by val_id) as utl_nla_array_flt) image_array \nfrom (select distinct image_id, label from testdata) a order by image_id;\n\n-- create the table with tensor definitions, the tensors are stored as arrays of type utl_nla_array\ncreate table tensors_array as\nselect a.name, cast(multiset(select val from tensors where name=a.name order by val_id) as utl_nla_array_flt) tensor_vals \nfrom (select distinct name from tensors) a;\n\nEOF')

get_ipython().run_cell_magic('bash', '', "sqlplus -s mnist/mnist@dbserver:1521/orcl.cern.ch  <<EOF\n\ncreate or replace package mnist\nas\n    -- MNIST scoring enginge in PL/SQL\n    -- Author: Luca.Canali@cern.ch, July 2016\n    g_b0_array utl_nla_array_flt;\n    g_W0_matrix utl_nla_array_flt;\n    g_b1_array utl_nla_array_flt;\n    g_W1_matrix utl_nla_array_flt;\n    \n    function score(p_testimage_array utl_nla_array_flt) return number;\n    procedure init;\nend;\n/\n\ncreate or replace package body mnist\nas\n    procedure init\n    /* initialize the tensors that make up the neural network */\n    as\n    begin\n        SELECT tensor_vals INTO g_W0_matrix FROM tensors_array WHERE name='W0';\n        SELECT tensor_vals INTO g_W1_matrix FROM tensors_array WHERE name='W1';\n        SELECT tensor_vals INTO g_b0_array FROM tensors_array WHERE name='b0';\n        SELECT tensor_vals INTO g_b1_array FROM tensors_array WHERE name='b1';\n    end;\n\n    procedure print_debug(p_array utl_nla_array_flt)\n    /* useful for debugging pourposes, prints an array to screen. requires set serveroutput on */\n    as\n    begin\n        dbms_output.put_line('***************');\n        for i in 1..p_array.count loop\n            dbms_output.put_line('p_array(' || i ||') = ' || TO_CHAR(p_array(i),'9999.9999'));\n        end loop;\n        dbms_output.put_line('**************');\n    end;\n    \n    function argmax(p_array utl_nla_array_flt)  return integer\n    as\n        v_index number;\n        v_maxval float;\n    begin\n        v_index := 1;\n        v_maxval := p_array(v_index);\n        for i in 2..p_array.count loop\n            if ( p_array(i) > v_maxval) then\n                v_index := i;\n                v_maxval := p_array(v_index);\n            end if; \n        end loop;\n    return(v_index);\n    end;\n\n    function score(p_testimage_array utl_nla_array_flt) return number\n    as\n        v_Y0 utl_nla_array_flt;\n        v_output_array utl_nla_array_flt;\n    begin\n        v_Y0 := g_b0_array;\n\n        /* this is part of the computation of the hidden layer, Y0 = W0_matrix * p_test_image_array + B0 */\n        /* utl_nla.blas_gemv performs matrix multiplication and vector addition */\n        utl_nla.blas_gemv(\n                      trans => 'N',\n                      m => 100,\n                      n => 784,\n                      alpha => 1.0,\n                      a => g_W0_matrix,\n                      lda => 100,\n                      x => p_testimage_array,\n                      incx => 1,\n                      beta => 1.0,\n                      y => v_Y0,\n                      incy => 1,\n                      pack => 'C'\n        );\n\n        /* This is part of the computation of the hidden layer: Y0 -> sigmoid(Y0) */\n        for i in 1..v_Y0.count loop\n            v_Y0(i) := 1 / ( 1 + exp(-v_Y0(i)));\n        end loop;\n\n        v_output_array := g_b1_array;\n\n        /* this is part of the computation of the output layer, Y1 = W1_matrix * Y0 + B1 */\n        /* utl_nla.blas_gemv performs matrix multiplication and vector addition */\n        utl_nla.blas_gemv(\n                      trans => 'N',\n                      m => 10,\n                      n => 100,\n                      alpha => 1.0,\n                      a => g_W1_matrix,\n                      lda => 10,\n                      x => v_Y0,\n                      incx => 1,\n                      beta => 1.0,\n                      y => v_output_array,\n                      incy => 1,\n                      pack => 'C'\n        );\n        \n        /* print_debug(v_output_array); */\n\n        /* v_output_array needs to be passed via softmax function to provide a distribution probability */\n        /* here we are only interested in the maximum value which gives the predicted number with an offset of 1 */\n        return (argmax(v_output_array) - 1);\n\n    end;\nend;\n/\nEOF")

get_ipython().run_cell_magic('bash', '', 'sqlplus -s mnist/mnist@dbserver:1521/orcl.cern.ch <<EOF\n\nexec mnist.init\nselect mnist.score(image_array), label from testdata_array where rownum=1;\n\nEOF')

get_ipython().run_cell_magic('bash', '', 'sqlplus -s mnist/mnist@dbserver:1521/orcl.cern.ch <<EOF\n\nexec mnist.init\nset timing on\nselect sum(decode(mnist.score(image_array), label, 1, 0)) "Images correctly identified",\n       count(*) "Total number of images" \nfrom testdata_array;\n\nEOF')



