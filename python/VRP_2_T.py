get_ipython().run_cell_magic('file', '"../pkg/vrp_2_t_cplex.py"', '\nimport numpy as np              # mathematic tools library\nimport networkx as nx           # network representation library\nfrom pkg.cplex_solve import cplex_solve\nimport cplex\n\ndef vrp_2_t_cplex(I,J,B,\n            c,f,\n            relaxation=False,path=None):\n\n    #####################################################################\n    # Decision variables\n    \n    def X(i,j,b):\n        return "X_" + str(i) + "_" + str(j) + "_" + str(b)\n    def U(i):\n        return "U_" + str(i)\n    def N(j):\n        return "N_" + str(j)\n    \n    IuJ = range(I+J); J = range(I,I+J,1)\n    I = range(I); B = range(B); \n    #####################################################################\n    # Objective function\n    Xs = {\n        "name" : [X(i,j,b) for i in IuJ for j in IuJ for b in B],\n        "coef" : [c[i][j] for i in IuJ for j in IuJ for b in B],\n        "type" : ["I" for i in IuJ for j in IuJ for b in B],\n        "ub"   : [1 for i in IuJ for j in IuJ for b in B],\n        "lb"   : [0 for i in IuJ for j in IuJ for b in B],\n    }\n    Ns = {\n        "name" : [N(j) for j in J],\n        "coef" : [f[j-len(I)] for j in J],\n        "type" : ["I" for j in J],\n        "ub"   : [1 for j in J],\n        "lb"   : [0 for j in J],\n    }\n    Us = {\n        "name" : [U(i) for i in IuJ],\n        "coef" : [0 for i in IuJ],\n        "type" : ["C" for i in IuJ],\n        "ub"   : [cplex.infinity for i in IuJ],\n        "lb"   : [0 for i in IuJ],\n    }\n\n    Variables = [Xs,Ns,Us]\n    ## Objective function sum aggregation\n    obj = [];ub = [];lb = [];colnames = [];types = [];\n    for v in Variables:\n        obj      = obj + v["coef"]\n        ub       = ub  + v["ub"]\n        lb       = lb  + v["lb"]\n        colnames = colnames + v["name"]\n        types    = types + v["type"]\n\n    #####################################################################\n    # Constraints\n    c0 = {\n        "lin_expr": [[[X(i,i,b) for i in IuJ for b in B],\n                      [1 for i in IuJ for b in B]] \n        ],\n        "senses"  : ["E"],\n        "rhs"     : [0]\n    }\n    c1 = {\n        "lin_expr": [[[X(i,j,b) for b in B for j in IuJ],\n                      [1 for b in B for j in IuJ]] \n         for i in I],\n        "senses"  : ["E" for i in I],\n        "rhs"     : [1 for i in I]\n    }\n    c2 = {\n        "lin_expr": [[[X(i,j,b) for i in IuJ if i!=j]+[X(j,i,b) for i in IuJ if i!=j], \n             [1 for i in IuJ if i!=j]+[-1 for i in IuJ if i!=j]] \n        for j in IuJ for b in B],\n        "senses"  : ["E" for j in IuJ for b in B],\n        "rhs"     : [0 for j in IuJ for b in B]\n    }\n    c3 = {\n        "lin_expr": [[[X(i,j,b) for i in IuJ for j in J],\n                      [1 for i in IuJ for j in J]] \n        for b in B],\n        "senses"  : ["L" for b in B],\n        "rhs"     : [1 for b in B]\n    }\n    c4 = {\n        "lin_expr": [[[U(i),U(j)]+[X(i,j,b) for b in B],\n                      [1,-1]+[len(I)+len(J) for b in B]] \n        for i in I for j in I if i!=j],\n        "senses"  : ["L" for i in I for j in I if i!=j],\n        "rhs"     : [len(I)+len(J)-1 for i in I for j in I if i!=j]\n    }\n\n    # Zs VRP constraints\n    Constraints = [c0,c1,c2,c3,c4]\n    rows = []; senses = []; rhs = [];\n    for c in Constraints:\n        rows   = rows   + c["lin_expr"]\n        senses = senses + c["senses"]\n        rhs    = rhs    + c["rhs"]\n\n    print(len(rows),len(senses),len(rhs))\n    \n    #####################################################################\n    # Solving\n    prob = cplex_solve(obj,ub,lb,colnames,types, rows, senses, rhs, minimize=True, path=path)\n\n    #####################################################################\n    # Extract solution\n    IuJ = len(I)+len(J); J = len(J)\n    I = len(I); B = len(B); \n    \n    solution = prob.solution.get_values()\n    X = np.reshape(solution[0:IuJ*IuJ*B],(IuJ,IuJ,B))\n    N = solution[IuJ*IuJ*B:IuJ*IuJ*B]\n\n    return prob, X, N')



