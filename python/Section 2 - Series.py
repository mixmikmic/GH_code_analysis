import pandas as pd

# Create a Series object from a python list
ice_cream = ['Chocolate', 'Vanilla', 'Strawberry', 'Rum Rasin']
# Notice the `dtype` is "object" due to these being strings
pd.Series(ice_cream)

lottery = [4,8,15,16,23,42]
# Notice the `dtype` is "int64" due to these being integers
pd.Series(lottery)

registrations = [True, False, False, False, True]
# Notice the `dtype` is "bool" due to these being all booleans
pd.Series(registrations)

webster = {
    'aardvark': "An animal",
    'banana': "A fruit",
    'cyan': "A color"
}
# Again we have a `dtype` of "object" becaus the values are strings. The index is our keys this time,
# instead of autogenerated numerical index. Index labels DO NOT have to be unique (unlike a dictionary's keys)
pd.Series(webster)

about_me = ["smart", "handsome", "charming", "brilliant", "humble"]
s = pd.Series(about_me)
s

# These are attributes, not functions, so no parenthesis

# Return an array with all the values in the Series
s.values

# Return an object describing the index of the Series
s.index

# dtype, description of the series
# 'O' means object
s.dtype

prices = [2.99,4.45,1.36]
s = pd.Series(prices)
s

# These are methods, not attributes, so do require the parenthesis
# sum() adds up all the values in the Series
s.sum()

# product() finds the product of the series
s.product()

# mean() finds the average o the series
s.mean()

fruits = ["apple", "orange", "plum", "grape", "blueberry"]
weekdays = ['mon', 'tues', 'wed', 'thur', 'fri']
pd.Series(fruits, weekdays)

pd.Series(data=fruits, index=weekdays)

pd.Series(fruits, index=weekdays)

# Indexes do not have to be unique. In this we have a second 'mon'
# IMPORTANT NOTE: With duplicates some methods will not be possible.
fruits = ["apple", "orange", "plum", "grape", "blueberry", "watermelon"]
weekdays = ['mon', 'tues', 'wed', 'thur', 'fri', 'mon']
pd.Series(data=fruits, index=weekdays)

pd.read_csv('datasets/pokemon.csv')

# We only want to use the pokemon column, excluding the type
pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"])

# We only want to import this as a series, not a dataframe
pokemon = pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"], squeeze = True)
pokemon

# Squeeze it to a series
google = pd.read_csv('datasets/google_stock_price.csv', squeeze = True)
google

pokemon = pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"], squeeze = True)
google = pd.read_csv('datasets/google_stock_price.csv', squeeze = True)

pokemon.head()

google.tail()

pokemon = pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"], squeeze = True)
google = pd.read_csv('datasets/google_stock_price.csv', squeeze = True)

# Number of rows in a series
len(pokemon)

# Find the type
type(google)

# dir - Find what we can do to our series
dir(pokemon)

sorted(pokemon)

sorted(google)

# Convert series to list
list(pokemon)

# Create dictionary from series with index as key
dict(google)

max(pokemon)

min(pokemon)

max(google)

min(google)

pokemon = pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"], squeeze = True)
google = pd.read_csv('datasets/google_stock_price.csv', squeeze = True)

pokemon.values

google.values

pokemon.index

google.index

pokemon.dtype

google.dtype

# Returns True if everything is unique
pokemon.is_unique

google.is_unique

# ndim - Return number of dimensions; In a series it is always 1
pokemon.ndim

# shape - return tuple of rows X columns (nothing in last element means 1 column)
pokemon.shape

# size - number of total cells in object; Does count null/NaN values
pokemon.size

# name - gives name of series
pokemon.name

# name can be reassigned to:
pokemon.name = "Pocket Monsters"
pokemon.head()

pokemon = pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"], squeeze = True)
google = pd.read_csv('datasets/google_stock_price.csv', squeeze = True)

pokemon.sort_values()

# sort_values() creates a new series, so we can use method chaining on that new series
pokemon.sort_values().head()

pokemon.sort_values(ascending=False)

pokemon.sort_values(ascending=False).tail()

google.sort_values()

google.sort_values(ascending=False).head(1)

pokemon = pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"], squeeze = True)
google = pd.read_csv('datasets/google_stock_price.csv', squeeze = True)

# First way of changing a series is to assign it back to the same variable
google = google.sort_values()
google.head()

google = pd.read_csv('datasets/google_stock_price.csv', squeeze = True)

# Second way is to pass the `inplace` parameter with a value of True
google.sort_values(ascending=False, inplace=True)
google.head()

pokemon = pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"], squeeze = True)
google = pd.read_csv('datasets/google_stock_price.csv', squeeze = True)

pokemon.sort_values(ascending=False, inplace=True)
pokemon.head()

pokemon.sort_index(inplace=True)
pokemon.head()

pokemon.sort_index(ascending=False, inplace=True)
pokemon.head()

pokemon = pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"], squeeze = True)
google = pd.read_csv('datasets/google_stock_price.csv', squeeze = True)

# Return True/False if value in list
100 in [1,2,3,4,5]

pokemon.head(3)

# Return True?
# No...returns False, because pandas looks at the *indexes* by default
"Bulbasaur" in pokemon

100 in pokemon  # 100 index in pokemon?
# Equivilant to 
# 100 in pokemon.index

# How to do original test: Is "balbasaur" in the pokemon series
"Bulbasaur" in pokemon.values

pokemon = pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"], squeeze = True)
google = pd.read_csv('datasets/google_stock_price.csv', squeeze = True)

# Return Pokemon value at the 500th index
pokemon[500]

# Extract more than one by using a list; Returns a new series in this case, instead of just a string
pokemon[[100,200,300]]

# Extract a range of indexes using slices; Second value is *exclusive*, not *inclusive*
pokemon[50:100]

pokemon = pd.read_csv('datasets/pokemon.csv')
# This is a dataframe (because we removed the single column imported)
pokemon

# Import it to have the pokemon as the index and the type as the value (and make it a series by include squeeze parameter)
pokemon = pd.read_csv('datasets/pokemon.csv', index_col="Pokemon", squeeze=True)
pokemon.head(3)

# Even though the index is a string now, pandas still assigns an unseen integer index
pokemon[0]

# Get value by pokemon name
pokemon["Bulbasaur"]

pokemon["Ditto"]

# Extract multiple using a list and return a series
pokemon[["Charizard", "Jolteon"]]

# Extract an unknown value (singular) - Returns an error
pokemon["Digimon"]

# Extract an unknown value in a list of values; Returns a series with BOTH, and a value of NaN on the unknown index
pokemon[["Pikachu", "Digimon"]]

# Slice a series (with this method, the second value *IS* inclusive)
pokemon["Bulbasaur":"Pikachu"]

pokemon = pd.read_csv('datasets/pokemon.csv', index_col="Pokemon", squeeze=True)
# Sort the index; Do this for performance improvements on large datasets
pokemon.sort_index(inplace=True)
pokemon.head(3)

# Similar to square brackets in previous parts
pokemon.get(key="Moltres")

# Works with lists too
pokemon.get(key=["Moltres", "Meowth"])

# When used with unknown keys, seems to return nothing because get() has a `default` parameter which is returned
# when value isn't found
pokemon.get(key="Digimon")

pokemon.get(key="Digimon", default="This isn't a Pokemon")

# Default doesn't work when passing a list with an unknown value
pokemon.get(key=["Charizard","Digimon"], default="This isn't a Pokemon")

google = pd.read_csv('datasets/google_stock_price.csv', squeeze=True)
google.head(3)

# coun() - Count of the number of valid values
# If we have NaN values, they are not counted (unlike using len())
google.count()

# sum() - Totals the values
google.sum()

# mean() - returns the mean of the series
google.mean()

# Valid the above:
google.sum() / google.count()

# std() - Standard Diviation
google.std()

# min() - Min value
google.min()

# max() - Max value in series
google.max()

# median - Median value in series
google.median()

# mode() - Most frequent value; If there are multiple modes, it will return all in the series
google.mode()

# describe() - Does many of the above calculations
google.describe()

google = pd.read_csv('datasets/google_stock_price.csv', squeeze=True)

google.max(), google.min()

# Return the index label storing the max() value
google.idxmax()

# Check that this index matches the above max
google[3011]

# Return index label storing the min() value
google.idxmin()

# Check that this index matches the above min
google[11]

# Can combine a couple of the above steps to replicae min()/max() functions
google[google.idxmax()], google[google.idxmin()]

pokemon = pd.read_csv('datasets/pokemon.csv', index_col="Pokemon", squeeze=True)

# count of all the unique values (Returns a new Series)
pokemon.value_counts()

# Can chain methods (below will return total length of series)
pokemon.value_counts().sum()

pokemon.count()

# Reverse order of our counts
pokemon.value_counts(ascending=True)

google = pd.read_csv('datasets/google_stock_price.csv', squeeze=True)
google.head(6)

def classify_performance(number):
    if number < 300:
        return "OK"
    elif number >= 300 and number < 650:
        return "Satisfactory"
    else:
        return "Incredible"

google.apply(classify_performance)

google.head(6)

# Add 1 every value
google.apply(lambda stock_price: stock_price + 1).head(6)

pokemon_names = pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"], squeeze=True)
pokemon_names.head(3)

pokemon_types = pd.read_csv('datasets/pokemon.csv', index_col = "Pokemon", squeeze=True)
pokemon_types.head(3)

# Take a series (pokemon_names) and look at the passed Series's (pokemon_types) *indexes* and if match, take value in second
# and return a new series
pokemon_names.map(pokemon_types)

# Reimport
pokemon_names = pd.read_csv('datasets/pokemon.csv', usecols = ["Pokemon"], squeeze=True)
# Create a dictionary for types
pokemon_types = pd.read_csv('datasets/pokemon.csv', index_col = "Pokemon", squeeze=True).to_dict()

pokemon_names.head(5)

pokemon_types

# Now we have two different datatypes - a Series and a dictionary
# This time, it will look for the keys in the dictionary
pokemon_names.map(pokemon_types)

