get_ipython().run_cell_magic('script', 'glpsol -m /dev/stdin', '\n/* Vehicle Routing Problem with Time Windows\n Jeffrey Kantor\n March, 2013\n*/\n\n# DATA SETS (TO BE GIVEN IN THE DATA SECTION)\n\nparam maxspeed > 0;\nparam minspeed > 0, <= maxspeed;\n\n# CUSTOMERS is a set of (name,location) pairs \nset CUSTOMERS dimen 2;\nparam T1{CUSTOMERS};\nparam T2{(name,loc) in CUSTOMERS} >= T1[name,loc];\n\n# PLANES is a set of (name, start_location, finish_location) triples\nset PLANES dimen 3;\nparam S1{PLANES};\nparam S2{(p,sLoc,fLoc) in PLANES} >= S1[p,sLoc,fLoc];\nparam F1{PLANES};\nparam F2{(p,sLoc,fLoc) in PLANES} >= F1[p,sLoc,fLoc];\n\n# set of locations\nset LOCATIONS;\nparam lat{LOCATIONS};\nparam lng{LOCATIONS};\n\n# DATA PREPROCESSING\n\n# set of planes\nset P := setof {(p,sLoc,fLoc) in PLANES} p;\n\n# compute START as (plane,startlocation) pairs with time windows\nset START := setof {(p,sLoc,fLoc) in PLANES} (p,sLoc);\nparam TS1{(p,sLoc) in START} := \n    max{ (q,tLoc,fLoc) in PLANES : (p=q) && (sLoc=tLoc) } S1[p,sLoc,fLoc];\nparam TS2{(p,sLoc) in START} := \n    min{ (q,tLoc,fLoc) in PLANES : (p=q) && (sLoc=tLoc) } S2[p,sLoc,fLoc];\n\n# compute FINISH as (plane,finishlocation) pairs with  time windows\nset FINISH := setof {(p,sLoc,fLoc) in PLANES} (p,fLoc);\nparam TF1{(p,fLoc) in FINISH} := \n    max{ (q,sLoc,gLoc) in PLANES : (p=q) && (fLoc=gLoc) } F1[p,sLoc,fLoc];\nparam TF2{(p,fLoc) in FINISH} := \n    min{ (q,sLoc,gLoc) in PLANES : (p=q) && (fLoc=gLoc) } F2[p,sLoc,fLoc];\n\n# create a complete of nodes as (name, location) pairs\nset N := CUSTOMERS union (START union FINISH);\n\n# great circle distances between locations\nparam d2r := 3.1415926/180;\nparam alpha{a in LOCATIONS, b in LOCATIONS} := sin(d2r*(lat[a]-lat[b])/2)**2 \n    + cos(d2r*lat[a])*cos(d2r*lat[b])*sin(d2r*(lng[a]-lng[b])/2)**2;\nparam gcdist{a in LOCATIONS, b in LOCATIONS} := \n    2*6371*atan( sqrt(alpha[a,b]), sqrt(1-alpha[a,b]) );\n\n# DECISION VARIABLES\n\n# x[p,a,aLoc,b,bLoc] = 1 if plane p flies from (a,aLoc) to (b,bLoc)\nvar x{P, N, N} binary;\n\n# START AND FINISH CONSTRAINTS\n\n# no planes arrive at the start nodes\ns.t. sf1 {p in P, (a,aLoc) in  N, (b,bLoc) in START} : \n        x[p,a,aLoc,b,bLoc] = 0;\n\n# no planes leave the finish nodes\ns.t. sf2 {p in P, (a,aLoc) in FINISH, (b,bLoc) in N} : \n        x[p,a,aLoc,b,bLoc] = 0;\n\n# planes must leave from their own start nodes\ns.t. sf3 {p in P, (a,aLoc) in START, (b,bLoc) in N : p != a} : \n        x[p,a,aLoc,b,bLoc] = 0;\n\n# planes must return to their own finish nodes\ns.t. sf4 {p in P, (a,aLoc) in N, (b,bLoc) in FINISH : p != b} : \n        x[p,a,aLoc,b,bLoc] = 0;\n\n# NETWORK CONSTRAINTS\n\n# one plane arrives at each customer and finish node\ns.t. nw1 {(b,bLoc) in (CUSTOMERS union FINISH)} : \n        sum {p in P, (a,aLoc) in (CUSTOMERS union START)} x[p,a,aLoc,b,bLoc] = 1;\n\n# one plane leaves each start and customer node\ns.t. nw2 {(a,aLoc) in (START union CUSTOMERS)} :\n        sum {p in P, (b,bLoc) in (CUSTOMERS union FINISH)} x[p,a,aLoc,b,bLoc] = 1;\n\n# planes entering a customer node must leave the same node\ns.t. nw3 {p in P, (a,aLoc) in CUSTOMERS} : \n    sum {(b,bLoc) in (CUSTOMERS union START)} x[p,b,bLoc,a,aLoc]\n        = sum {(b,bLoc) in (CUSTOMERS union FINISH)} x[p,a,aLoc,b,bLoc];\n\n# no self loops\ns.t. nw4 {p in P, (a,aLoc) in N, (b,bLoc) in N : (a=b) && (aLoc=bLoc)} :\n    x[p,a,aLoc,b,bLoc] = 0;\n\n# SUBTOUR ELIMINATION CONSTRAINTS\n\nvar y{P,N,N} >= 0;\n\n# route capacity\ns.t. sb1 {p in P, (a,aLoc) in N, (b,bLoc) in N} : \n    y[p,a,aLoc,b,bLoc] <= card(CUSTOMERS)*x[p,a,aLoc,b,bLoc];\n\n# allocate tokens to links from the start nodes\ns.t. sb2 : sum {p in P, (a,aLoc) in START, (b,bLoc) in N } y[p,a,aLoc,b,bLoc] \n               = card(CUSTOMERS);\n\n# decrease tokens for each step on a path\ns.t. sb3 {(a,aLoc) in CUSTOMERS} : \n    sum{p in P, (b,bLoc) in (CUSTOMERS union START)} y[p,b,bLoc,a,aLoc] \n        = 1 + sum{p in P, (b,bLoc) in (CUSTOMERS union FINISH)} y[p,a,aLoc,b,bLoc];\n\n# TIME WINDOW CONSTRAINTS\nparam bigM := 50;\nvar tar{N};\nvar tlv{N};\nvar tea{N} >= 0;\nvar tla{N} >= 0;\nvar ted{N} >= 0;\nvar tld{N} >= 0;\n\ns.t. t00 {(a,aLoc) in N} : tlv[a,aLoc] >= tar[a,aLoc];\ns.t. t01 {p in P, (a,aLoc) in N, (b,bLoc) in N} : tar[b,bLoc] >= tlv[a,aLoc] \n        + gcdist[aLoc,bLoc]/maxspeed - bigM*(1-x[p,a,aLoc,b,bLoc]);\ns.t. t02 {p in P, (a,aLoc) in N, (b,bLoc) in N} : tar[b,bLoc] <= tlv[a,aLoc] \n        + gcdist[aLoc,bLoc]/minspeed + bigM*(1-x[p,a,aLoc,b,bLoc]);\ns.t. t03 {(a,aLoc) in CUSTOMERS} : tea[a,aLoc] >= T1[a,aLoc] - tar[a,aLoc];\ns.t. t04 {(a,aLoc) in FINISH} :    tea[a,aLoc] >= TF1[a,aLoc] - tar[a,aLoc];\ns.t. t05 {(a,aLoc) in CUSTOMERS} : tla[a,aLoc] >= tar[a,aLoc] - T2[a,aLoc];\ns.t. t06 {(a,aLoc) in FINISH} :    tla[a,aLoc] >= tar[a,aLoc] - TF2[a,aLoc];\ns.t. t07 {(a,aLoc) in START} :     ted[a,aLoc] >= TS1[a,aLoc] - tlv[a,aLoc];\ns.t. t08 {(a,aLoc) in CUSTOMERS} : ted[a,aLoc] >= T1[a,aLoc] - tlv[a,aLoc];\ns.t. t09 {(a,aLoc) in START} :     tld[a,aLoc] >= tlv[a,aLoc] - TS2[a,aLoc];\ns.t. t10 {(a,aLoc) in CUSTOMERS} : tld[a,aLoc] >= tlv[a,aLoc] - T2[a,aLoc];\n\n# OBJECTIVE\n# The objective function is a weighted sum of violations of the time window\n# constraints and the total distance traveled. \n\nvar routeDistance{P} >= 0;\ns.t. ob1 {p in P} : routeDistance[p] \n        = sum{(a,aLoc) in N, (b,bLoc) in N} gcdist[aLoc,bLoc]*x[p,a,aLoc,b,bLoc];\n\nvar totalDistance >= 0;\ns.t. ob2 : totalDistance = sum{p in P} routeDistance[p];\n\nvar timePenalty >= 0;\ns.t. ob3 : timePenalty = \n    sum{(a,aLoc) in N} (tea[a,aLoc] + 2*tla[a,aLoc] + 2*ted[a,aLoc] + tld[a,aLoc]);\n\nminimize obj: 5*timePenalty + totalDistance/maxspeed;\n\nsolve;\n\n# OUTPUT POST-PROCESSING\n\nparam routeTime{p in P} := \n    sum{(a,aLoc) in N, (b,bLoc) in N} (tar[b,bLoc]-tlv[a,aLoc])*x[p,a,aLoc,b,bLoc];\n\nparam routeLegs{p in P} :=\n    sum{(a,aLoc) in START, (b,bLoc) in N} y[p,a,aLoc,b,bLoc];\n\nfor {p in P} {\n    printf "\\nRouting for %s\\n-------------------\\n", p;\n    printf "%-24s  %-24s  %7s %5s %6s \\n", \n        \'Depart\',\'Arrive\',\'Dist.\',\'Time\',\'Speed\';\n    for {k in routeLegs[p]..0 by -1} {\n        printf {(a,aLoc) in N, (b,bLoc) in N : \n            (x[p,a,aLoc,b,bLoc] = 1) && (abs(y[p,a,aLoc,b,bLoc]-k)<0.001)} \n            "%-12s %-4s %5.2f%1s  %-12s %-4s %5.2f%1s  %7.1f %5.2f %6.1f\\n",\n            a, aLoc, tlv[a,aLoc], \n            if (ted[a,aLoc] > 0) then "E" else (if (tld[a,aLoc] > 0) then "L" else " "),\n            b, bLoc, tar[b,bLoc],\n            if (tea[b,bLoc] > 0) then "E" else (if (tla[b,bLoc] > 0) then "L" else " "),\n            gcdist[aLoc,bLoc], tar[b,bLoc]-tlv[a,aLoc], \n            if (gcdist[aLoc,bLoc] > 0) then gcdist[aLoc,bLoc]/(tar[b,bLoc]-tlv[a,aLoc]) else 0;\n    }\n    printf "%50s  %7s %5s\\n", \'\', \'-------\',\'-----\';\n    printf "%50s  %7.1f %5.2f\\n\\n", \'Totals:\', routeDistance[p], routeTime[p];\n}\n\n# DATA SECTION\n\ndata;\n\nparam maxspeed := 800;\nparam minspeed := 600;\n\nparam : CUSTOMERS :            T1      T2 := \n        \'Atlanta\'      ATL     8.0    24.0\n        \'Boston\'       BOS     8.0     9.0\n        \'Denver\'       DEN    12.0    15.0\n        \'Dallas\'       DFW    12.0    13.0\n        \'New York\'     JFK    18.0    20.0\n        \'Los Angeles\'  LAX    12.0    16.0\n        \'Chicago\'      ORD    20.0    24.0\n        \'St. Louis\'    STL    11.0    13.0\n;\n\nparam : PLANES :                     S1     S2     F1     F2 :=\n        \'Plane 1\'    ORD    ORD_    8.0   24.0    8.0   24.0\n        \'Plane 2\'    DFW    DRW_    8.0   24.0    8.0   24.0\n;\n\nparam : LOCATIONS : lat           lng :=\n        ATL   33.6366995   -84.4278639\n        BOS   42.3629722   -71.0064167\n        DEN   39.8616667  -104.6731667\n        DFW   32.8968281   -97.0379958  # start location\n        DRW_  32.8968281   -97.0379958  # finish location\n        JFK   40.6397511   -73.7789256\n        LAX   33.9424955  -118.4080684\n        ORD   41.9816486   -87.9066714  # start location\n        ORD_  41.9816486   -87.9066714  # finish location\n        STL   38.7486972   -90.3700289\n; \n\nend;')



